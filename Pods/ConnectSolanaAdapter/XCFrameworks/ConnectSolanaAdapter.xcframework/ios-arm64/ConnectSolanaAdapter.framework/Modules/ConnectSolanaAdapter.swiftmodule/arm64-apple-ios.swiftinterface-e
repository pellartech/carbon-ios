// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name ConnectSolanaAdapter
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Accelerate
import CommonCrypto
import ConnectCommon
@_exported import ConnectSolanaAdapter
import CryptoSwift
import Foundation
import ParticleNetworkBase
import RxAlamofire
import RxSwift
import Swift
import SwiftyJSON
import SwiftyUserDefaults
import TweetNacl
import _Concurrency
import _StringProcessing
import secp256k1
import Accelerate.vecLib
public enum AssociatedTokenProgram : ConnectSolanaAdapter.SolanaBasicProgram {
  public static var id: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static func createAssociatedTokenAccountInstruction(mint: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, payer: ConnectSolanaAdapter.PublicKey) throws -> ConnectSolanaAdapter.TransactionInstruction
}
public class SolanaConnectAdapter : ConnectCommon.ConnectAdapter, ConnectCommon.LocalAdapter {
  public init(rpcUrl: Swift.String = RpcUrl.solana)
  public var walletType: ConnectCommon.WalletType {
    get
  }
  public func handleUrl(_ url: Foundation.URL) -> Swift.Bool
  public var readyState: ConnectCommon.WalletReadyState {
    get
  }
  public func getAccounts() -> [ConnectCommon.Account]
  public func connect<T>(_ config: T? = nil) -> RxSwift.Single<ConnectCommon.Account?> where T : ConnectCommon.ConnectConfig
  public func isConnected(publicAddress: Swift.String) -> Swift.Bool
  public func disconnect(publicAddress: Swift.String) -> RxSwift.Single<Swift.String>
  public func signAndSendTransaction(publicAddress: Swift.String, transaction: Swift.String) -> RxSwift.Single<Swift.String>
  public func signAndSendTransaction(publicAddress: Swift.String, transaction: ConnectSolanaAdapter.SolanaTransaction) -> RxSwift.Single<Swift.String>
  public func signAllTransactions(publicAddress: Swift.String, transactions: [Swift.String]) -> RxSwift.Single<[Swift.String]>
  public func signTransaction(publicAddress: Swift.String, transaction: Swift.String) -> RxSwift.Single<Swift.String>
  public func signAllTransactions(publicAddress: Swift.String, transactions: [ConnectSolanaAdapter.SolanaTransaction]) -> RxSwift.Single<[Swift.String]>
  public func signTransaction(publicAddress: Swift.String, transaction: ConnectSolanaAdapter.SolanaTransaction) -> RxSwift.Single<Swift.String>
  public func signMessage(publicAddress: Swift.String, message: Swift.String) -> RxSwift.Single<Swift.String>
  public func signTypeData(publicAddress: Swift.String, data: Swift.String) -> RxSwift.Single<Swift.String>
  public func importWalletFromPrivateKey(_ privateKey: Swift.String) -> RxSwift.Single<ConnectCommon.Account?>
  public func importWalletFromMnemonic(_ mnemonic: Swift.String) -> RxSwift.Single<ConnectCommon.Account?>
  public func exportWalletPrivateKey(publicAddress: Swift.String) -> RxSwift.Single<Swift.String?>
  public func request(publicAddress: Swift.String, method: Swift.String, parameters: [Swift.Encodable]) -> RxSwift.Single<SwiftyJSON.JSON?>
  public func switchEthereumChain(publicAddress: Swift.String, chainId: Swift.Int) -> RxSwift.Single<Swift.String>
  public func addEthereumChain(publicAddress: Swift.String, chainId: Swift.Int, chainName: Swift.String?, nativeCurrency: ConnectCommon.NativeCurrency?, rpcUrl: Swift.String?, blockExplorerUrl: Swift.String?) -> RxSwift.Single<Swift.String>
  @objc deinit
}
public typealias TransactionID = Swift.String
public typealias Lamports = Swift.UInt64
public typealias Decimals = Swift.UInt8
public struct SocketParams<T> : Swift.Decodable where T : Swift.Decodable {
  public let result: ConnectSolanaAdapter.Rpc<T>?
  public let subscription: Swift.UInt64?
  public init(from decoder: Swift.Decoder) throws
}
public struct ResponseError : Swift.Decodable, Swift.Equatable {
  public init(code: Swift.Int?, message: Swift.String?, data: ConnectSolanaAdapter.ResponseErrorData?)
  public let code: Swift.Int?
  public let message: Swift.String?
  public let data: ConnectSolanaAdapter.ResponseErrorData?
  public static func == (a: ConnectSolanaAdapter.ResponseError, b: ConnectSolanaAdapter.ResponseError) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
}
public struct ResponseErrorData : Swift.Decodable, Swift.Equatable {
  public let logs: [Swift.String]?
  public let numSlotsBehind: Swift.Int?
  public static func == (a: ConnectSolanaAdapter.ResponseErrorData, b: ConnectSolanaAdapter.ResponseErrorData) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
}
public struct Rpc<T> : Swift.Decodable where T : Swift.Decodable {
  public let context: ConnectSolanaAdapter.Context
  public let value: T
  public init(from decoder: Swift.Decoder) throws
}
public struct Context : Swift.Decodable {
  public let slot: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct BlockCommitment : Swift.Decodable {
  public let commitment: [Swift.UInt64]?
  public let totalStake: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct ClusterNodes : Swift.Decodable {
  public let pubkey: Swift.String
  public let gossip: Swift.String
  public let tpu: Swift.String?
  public let rpc: Swift.String?
  public let version: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct ConfirmedBlock : Swift.Decodable {
  public let blockhash: Swift.String
  public let previousBlockhash: Swift.String
  public let parentSlot: Swift.UInt64
  public let transactions: [ConnectSolanaAdapter.TransactionInfo]
  public let rewards: [ConnectSolanaAdapter.Reward]
  public let blockTime: Swift.UInt64?
  public init(from decoder: Swift.Decoder) throws
}
public struct Reward : Swift.Decodable {
  public let pubkey: Swift.String
  public let lamports: ConnectSolanaAdapter.Lamports
  public let postBalance: ConnectSolanaAdapter.Lamports
  public let rewardType: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct EpochInfo : Swift.Decodable {
  public let absoluteSlot: Swift.UInt64
  public let blockHeight: Swift.UInt64
  public let epoch: Swift.UInt64
  public let slotIndex: Swift.UInt64
  public let slotsInEpoch: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct EpochSchedule : Swift.Decodable {
  public let slotsPerEpoch: Swift.UInt64
  public let leaderScheduleSlotOffset: Swift.UInt64
  public let warmup: Swift.Bool
  public let firstNormalEpoch: Swift.UInt64
  public let firstNormalSlot: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct Fee : Swift.Decodable {
  public let feeCalculator: ConnectSolanaAdapter.FeeCalculatorResponse?
  public let feeRateGovernor: ConnectSolanaAdapter.FeeRateGovernor?
  public let blockhash: Swift.String?
  public let lastValidSlot: Swift.UInt64?
  public init(from decoder: Swift.Decoder) throws
}
public struct FeeCalculatorResponse : Swift.Decodable {
  public let lamportsPerSignature: ConnectSolanaAdapter.Lamports
  public init(from decoder: Swift.Decoder) throws
}
public struct FeeRateGovernor : Swift.Decodable {
  public let burnPercent: Swift.UInt64
  public let maxLamportsPerSignature: ConnectSolanaAdapter.Lamports
  public let minLamportsPerSignature: ConnectSolanaAdapter.Lamports
  public let targetLamportsPerSignature: ConnectSolanaAdapter.Lamports
  public let targetSignaturesPerSlot: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct Identity : Swift.Decodable {
  public let identity: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct InflationGovernor : Swift.Decodable {
  public let foundation: Swift.Float64
  public let foundationTerm: Swift.Float64
  public let initial: Swift.Float64
  public let taper: Swift.Float64
  public let terminal: Swift.Float64
  public init(from decoder: Swift.Decoder) throws
}
public struct InflationRate : Swift.Decodable {
  public let epoch: Swift.Float64
  public let foundation: Swift.Float64
  public let total: Swift.Float64
  public let validator: Swift.Float64
  public init(from decoder: Swift.Decoder) throws
}
public struct LargestAccount : Swift.Decodable {
  public let lamports: ConnectSolanaAdapter.Lamports
  public let address: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct ProgramAccounts<T> : Swift.Decodable where T : ConnectSolanaAdapter.BufferLayout {
  public let accounts: [ConnectSolanaAdapter.ProgramAccount<T>]
  public init(from decoder: Swift.Decoder) throws
}
public struct ProgramAccount<T> : Swift.Decodable where T : ConnectSolanaAdapter.BufferLayout {
  public let account: ConnectSolanaAdapter.BufferInfo<T>
  public let pubkey: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct BufferInfo<T> : Swift.Decodable where T : ConnectSolanaAdapter.BufferLayout {
  public let lamports: ConnectSolanaAdapter.Lamports
  public let owner: Swift.String
  public let data: T
  public let executable: Swift.Bool
  public let rentEpoch: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct BufferInfoParsed<T> : Swift.Decodable where T : Swift.Decodable {
  public let lamports: ConnectSolanaAdapter.Lamports
  public let owner: Swift.String
  public let data: T?
  public let executable: Swift.Bool
  public let rentEpoch: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct PerformanceSample : Swift.Decodable {
  public let numSlots: Swift.UInt64
  public let numTransactions: Swift.UInt64
  public let samplePeriodSecs: Swift.UInt
  public let slot: Swift.UInt64
  public init(from decoder: Swift.Decoder) throws
}
public struct SignatureInfo : Swift.Decodable {
  public let signature: Swift.String
  public let slot: Swift.UInt64?
  public let err: ConnectSolanaAdapter.TransactionError?
  public let memo: Swift.String?
  public let blockTime: Swift.UInt64?
  public init(signature: Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
public struct SignatureStatus : Swift.Decodable {
  public let slot: Swift.UInt64
  public let confirmations: Swift.UInt64?
  public let err: ConnectSolanaAdapter.TransactionError?
  public let confirmationStatus: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct TransactionInfo : Swift.Decodable {
  public let blockTime: Swift.UInt64?
  public let meta: ConnectSolanaAdapter.TransactionMeta?
  public let transaction: ConnectSolanaAdapter.ConfirmedTransaction
  public let slot: Swift.UInt64?
  public init(from decoder: Swift.Decoder) throws
}
public struct TransactionMeta : Swift.Decodable {
  public let err: ConnectSolanaAdapter.TransactionError?
  public let fee: ConnectSolanaAdapter.Lamports?
  public let innerInstructions: [ConnectSolanaAdapter.InnerInstruction]?
  public let logMessages: [Swift.String]?
  public let postBalances: [ConnectSolanaAdapter.Lamports]?
  public let postTokenBalances: [ConnectSolanaAdapter.TokenBalance]?
  public let preBalances: [ConnectSolanaAdapter.Lamports]?
  public let preTokenBalances: [ConnectSolanaAdapter.TokenBalance]?
  public init(from decoder: Swift.Decoder) throws
}
public typealias TransactionError = [Swift.String : [ConnectSolanaAdapter.ErrorDetail]]
public struct ErrorDetail : Swift.Codable {
  public init(wrapped: Any)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InnerInstruction : Swift.Decodable {
  public let index: Swift.UInt32
  public let instructions: [ConnectSolanaAdapter.ParsedInstruction]
  public init(from decoder: Swift.Decoder) throws
}
public struct TokenBalance : Swift.Decodable {
  public let accountIndex: Swift.UInt64
  public let mint: Swift.String
  public let uiTokenAmount: ConnectSolanaAdapter.TokenAccountBalance
  public init(from decoder: Swift.Decoder) throws
}
public struct SimulationResult : Swift.Decodable {
  public let err: ConnectSolanaAdapter.ErrorDetail?
  public let logs: [Swift.String]
  public init(from decoder: Swift.Decoder) throws
}
public struct StakeActivation : Swift.Decodable {
  public let active: Swift.UInt64
  public let inactive: Swift.UInt64
  public let state: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct Supply : Swift.Decodable {
  public let circulating: ConnectSolanaAdapter.Lamports
  public let nonCirculating: ConnectSolanaAdapter.Lamports
  public let nonCirculatingAccounts: [Swift.String]
  public let total: ConnectSolanaAdapter.Lamports
  public init(from decoder: Swift.Decoder) throws
}
public struct TokenAccountBalance : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public init(uiAmount: Swift.Float64?, amount: Swift.String, decimals: Swift.UInt8?, uiAmountString: Swift.String?)
  public init(amount: Swift.String, decimals: Swift.UInt8?)
  public let uiAmount: Swift.Float64?
  public let amount: Swift.String
  public let decimals: Swift.UInt8?
  public let uiAmountString: Swift.String?
  public var amountInUInt64: Swift.UInt64? {
    get
  }
  public static func == (a: ConnectSolanaAdapter.TokenAccountBalance, b: ConnectSolanaAdapter.TokenAccountBalance) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct TokenAccount<T> : Swift.Decodable where T : ConnectSolanaAdapter.BufferLayout {
  public let pubkey: Swift.String
  public let account: ConnectSolanaAdapter.BufferInfo<T>
  public init(from decoder: Swift.Decoder) throws
}
public struct TokenAmount : Swift.Decodable {
  public let address: Swift.String?
  public let amount: Swift.String
  public let decimals: Swift.UInt8
  public let uiAmount: Swift.Float64
  public init(from decoder: Swift.Decoder) throws
}
public struct Version : Swift.Decodable {
  public let solanaCore: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct VoteAccounts : Swift.Decodable {
  public let current: [ConnectSolanaAdapter.VoteAccount]
  public let delinquent: [ConnectSolanaAdapter.VoteAccount]
  public init(from decoder: Swift.Decoder) throws
}
public struct VoteAccount : Swift.Decodable {
  public let commission: Swift.Int
  public let epochVoteAccount: Swift.Bool
  public let epochCredits: [[Swift.UInt64]]
  public let nodePubkey: Swift.String
  public let lastVote: Swift.UInt64
  public let activatedStake: Swift.UInt64
  public let votePubkey: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct Mint : ConnectSolanaAdapter.BufferLayout, Swift.Equatable, Swift.Hashable, Swift.Encodable {
  public static var BUFFER_LENGTH: Swift.UInt64
  public let mintAuthorityOption: Swift.UInt32
  public let mintAuthority: ConnectSolanaAdapter.PublicKey?
  public let supply: Swift.UInt64
  public let decimals: Swift.UInt8
  public let isInitialized: Swift.Bool
  public let freezeAuthorityOption: Swift.UInt32
  public let freezeAuthority: ConnectSolanaAdapter.PublicKey?
  public static func == (a: ConnectSolanaAdapter.Mint, b: ConnectSolanaAdapter.Mint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension ConnectSolanaAdapter.Mint : ConnectSolanaAdapter.BorshCodable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
        self = [Element]()
        self.reserveCapacity(reserveCapacity)
    }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
        self[startIndex ..< endIndex]
    }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
extension ConnectSolanaAdapter.RIPEMD {
  public struct Block {
    public init()
    public var hash: [Swift.UInt32] {
      get
    }
    public mutating func compress(_ message: [Swift.UInt32])
    public func f(_ j: Swift.Int) -> ((Swift.UInt32, Swift.UInt32, Swift.UInt32) -> Swift.UInt32)
    public enum K {
      case left, right
      public subscript(j: Swift.Int) -> Swift.UInt32 {
        get
      }
      public static func == (a: ConnectSolanaAdapter.RIPEMD.Block.K, b: ConnectSolanaAdapter.RIPEMD.Block.K) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum r {
      case left, right
      public subscript(j: Swift.Int) -> Swift.Int {
        get
      }
      public static func == (a: ConnectSolanaAdapter.RIPEMD.Block.r, b: ConnectSolanaAdapter.RIPEMD.Block.r) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum s {
      case left, right
      public subscript(j: Swift.Int) -> Swift.Int {
        get
      }
      public static func == (a: ConnectSolanaAdapter.RIPEMD.Block.s, b: ConnectSolanaAdapter.RIPEMD.Block.s) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
}
public protocol BorshDeserializable {
  init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.FixedWidthInteger {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.UInt8 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.UInt16 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.UInt32 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.UInt64 : ConnectSolanaAdapter.BorshDeserializable {
}
extension ConnectSolanaAdapter.UInt2X : ConnectSolanaAdapter.BorshDeserializable where Word == Swift.UInt64 {
}
extension Swift.Int8 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.Int16 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.Int32 : ConnectSolanaAdapter.BorshDeserializable {
}
extension Swift.Int64 : ConnectSolanaAdapter.BorshDeserializable {
}
extension ConnectSolanaAdapter.Int2X : ConnectSolanaAdapter.BorshDeserializable where Word == Swift.UInt64 {
}
extension Swift.Float : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.Double : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.Bool : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.String : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.Array : ConnectSolanaAdapter.BorshDeserializable where Element : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.Set : ConnectSolanaAdapter.BorshDeserializable where Element : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension Swift.Dictionary : ConnectSolanaAdapter.BorshDeserializable where Key : ConnectSolanaAdapter.BorshDeserializable, Value : ConnectSolanaAdapter.BorshDeserializable {
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
public struct Throwable<T> : Swift.Decodable where T : Swift.Decodable {
  public let result: Swift.Result<T, Swift.Error>
  public init(from decoder: Swift.Decoder) throws
}
public struct SolanaTransaction {
  public var signatures: [ConnectSolanaAdapter.SolanaTransaction.Signature]
  public var feePayer: ConnectSolanaAdapter.PublicKey?
  public var instructions: [ConnectSolanaAdapter.TransactionInstruction]
  public var recentBlockhash: Swift.String?
  public init()
  public init(instructions: [ConnectSolanaAdapter.TransactionInstruction], recentBlockhash: Swift.String?, feePayer: ConnectSolanaAdapter.PublicKey)
  public mutating func sign(signers: [ConnectSolanaAdapter.SolanaAccount]) throws
  public func calculateTransactionFee(lamportsPerSignatures: Swift.UInt64) throws -> Swift.UInt64
  public mutating func serialize(requiredAllSignatures: Swift.Bool = true, verifySignatures: Swift.Bool = false) throws -> Foundation.Data
  public mutating func addSignature(_ signature: ConnectSolanaAdapter.SolanaTransaction.Signature) throws
  public mutating func verifySignatures() throws -> Swift.Bool
  public func findSignature(pubkey: ConnectSolanaAdapter.PublicKey) -> ConnectSolanaAdapter.SolanaTransaction.Signature?
  public mutating func partialSign(signers: [ConnectSolanaAdapter.SolanaAccount]) throws
  public func compileMessage() throws -> ConnectSolanaAdapter.SolanaTransaction.Message
  public static func from(data: Foundation.Data) throws -> ConnectSolanaAdapter.SolanaTransaction
}
extension ConnectSolanaAdapter.SolanaTransaction {
  public struct Signature : Swift.Encodable {
    public var signature: Foundation.Data?
    public var publicKey: ConnectSolanaAdapter.PublicKey
    public init(signature: Foundation.Data?, publicKey: ConnectSolanaAdapter.PublicKey)
    public func encode(to encoder: Swift.Encoder) throws
  }
}
public struct AccountInfo : ConnectSolanaAdapter.BufferLayout {
  public static let BUFFER_LENGTH: Swift.UInt64
  public let mint: ConnectSolanaAdapter.PublicKey
  public let owner: ConnectSolanaAdapter.PublicKey
  public let lamports: Swift.UInt64
  public let delegateOption: Swift.UInt32
  public var delegate: ConnectSolanaAdapter.PublicKey?
  public let isInitialized: Swift.Bool
  public let isFrozen: Swift.Bool
  public let state: Swift.UInt8
  public let isNativeOption: Swift.UInt32
  public let rentExemptReserve: Swift.UInt64?
  public let isNativeRaw: Swift.UInt64
  public let isNative: Swift.Bool
  public var delegatedAmount: Swift.UInt64
  public let closeAuthorityOption: Swift.UInt32
  public var closeAuthority: ConnectSolanaAdapter.PublicKey?
  public func encode(to encoder: Swift.Encoder) throws
}
extension ConnectSolanaAdapter.AccountInfo : ConnectSolanaAdapter.BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
extension ConnectSolanaAdapter.SolanaTransaction {
  public struct Message {
    public var header: ConnectSolanaAdapter.SolanaTransaction.Message.Header {
      get
    }
    public var accountKeys: [ConnectSolanaAdapter.PublicKey] {
      get
    }
    public var instructions: [ConnectSolanaAdapter.SolanaTransaction.Message.CompiledInstruction] {
      get
    }
    public func isAccountWritable(index: Swift.Int) -> Swift.Bool
    public func isAccountSigner(index: Swift.Int) -> Swift.Bool
  }
}
extension ConnectSolanaAdapter.SolanaTransaction.Message {
  public struct Header : Swift.Decodable, Swift.Equatable {
    public static func == (a: ConnectSolanaAdapter.SolanaTransaction.Message.Header, b: ConnectSolanaAdapter.SolanaTransaction.Message.Header) -> Swift.Bool
    public init(from decoder: Swift.Decoder) throws
  }
  public struct CompiledInstruction {
    public let programIdIndex: Swift.UInt8
    public let data: [Swift.UInt8]
    public var accounts: [Swift.Int] {
      get
    }
  }
}
public struct TokenSwapInfo : ConnectSolanaAdapter.BufferLayout, Swift.Equatable, Swift.Hashable, Swift.Encodable {
  public static var BUFFER_LENGTH: Swift.UInt64
  public let version: Swift.UInt8
  public let isInitialized: Swift.Bool
  public let nonce: Swift.UInt8
  public let tokenProgramId: ConnectSolanaAdapter.PublicKey
  public var tokenAccountA: ConnectSolanaAdapter.PublicKey
  public var tokenAccountB: ConnectSolanaAdapter.PublicKey
  public let tokenPool: ConnectSolanaAdapter.PublicKey
  public var mintA: ConnectSolanaAdapter.PublicKey
  public var mintB: ConnectSolanaAdapter.PublicKey
  public let feeAccount: ConnectSolanaAdapter.PublicKey
  public let tradeFeeNumerator: Swift.UInt64
  public let tradeFeeDenominator: Swift.UInt64
  public let ownerTradeFeeNumerator: Swift.UInt64
  public let ownerTradeFeeDenominator: Swift.UInt64
  public let ownerWithdrawFeeNumerator: Swift.UInt64
  public let ownerWithdrawFeeDenominator: Swift.UInt64
  public let hostFeeNumerator: Swift.UInt64
  public let hostFeeDenominator: Swift.UInt64
  public let curveType: Swift.UInt8
  public let payer: ConnectSolanaAdapter.PublicKey
  public static func == (a: ConnectSolanaAdapter.TokenSwapInfo, b: ConnectSolanaAdapter.TokenSwapInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension ConnectSolanaAdapter.TokenSwapInfo : ConnectSolanaAdapter.BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
public protocol BytesEncodable {
  var bytes: [Swift.UInt8] { get }
}
extension Swift.UInt8 : ConnectSolanaAdapter.BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 : ConnectSolanaAdapter.BytesEncodable {
}
extension Swift.UInt32 : ConnectSolanaAdapter.BytesEncodable {
}
extension Foundation.Data : ConnectSolanaAdapter.BytesEncodable {
}
extension Swift.Bool : ConnectSolanaAdapter.BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.Array : ConnectSolanaAdapter.BytesEncodable where Element == ConnectSolanaAdapter.BytesEncodable {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.RawRepresentable where Self.RawValue == Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.RawRepresentable where Self.RawValue == Swift.UInt8 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
infix operator >>> : BitwiseShiftPrecedence
public struct BinaryReader {
  public init(bytes: [Swift.UInt8])
}
extension ConnectSolanaAdapter.BinaryReader {
  public mutating func read(count: Swift.UInt32) throws -> [Swift.UInt8]
}
infix operator ~<< : BitwiseShiftPrecedence
public func ~<< (lhs: Swift.UInt32, rhs: Swift.Int) -> Swift.UInt32
precedencegroup ExponentiationPrecedence {
  associativity: left
  higherThan: MultiplicationPrecedence
  lowerThan: BitwiseShiftPrecedence
}
infix operator ** : ExponentiationPrecedence
public struct BInt : Swift.SignedNumeric, Swift.BinaryInteger, Swift.ExpressibleByFloatLiteral {
  public typealias Magnitude = Swift.UInt64
  public var magnitude: Swift.UInt64 {
    get
  }
  public typealias Words = [Swift.UInt]
  public var words: ConnectSolanaAdapter.BInt.Words {
    get
  }
  public init(_ str: Swift.String)
  public init(floatLiteral value: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public var description: Swift.String {
    get
  }
  public init(number: Swift.String, withBase base: Swift.Int)
  public func asString(withBase base: Swift.Int) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static var isSigned: Swift.Bool {
    get
  }
  public func signum() -> ConnectSolanaAdapter.BInt
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public static func << <T>(lhs: ConnectSolanaAdapter.BInt, rhs: T) -> ConnectSolanaAdapter.BInt where T : Swift.BinaryInteger
  public static func <<= <T>(lhs: inout ConnectSolanaAdapter.BInt, rhs: T) where T : Swift.BinaryInteger
  public static func >> <T>(lhs: ConnectSolanaAdapter.BInt, rhs: T) -> ConnectSolanaAdapter.BInt where T : Swift.BinaryInteger
  public static func >>= <T>(lhs: inout ConnectSolanaAdapter.BInt, rhs: T) where T : Swift.BinaryInteger
  public static func & (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func &= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func | (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func |= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func ^ (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func ^= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  prefix public static func ~ (x: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func += (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func + (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public mutating func negate()
  prefix public static func - (n: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func - (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func -= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func * (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func *= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func ** (lhs: ConnectSolanaAdapter.BInt, rhs: Swift.Int) -> ConnectSolanaAdapter.BInt
  public func quotientAndRemainder(dividingBy rhs: ConnectSolanaAdapter.BInt) -> (quotient: ConnectSolanaAdapter.BInt, remainder: ConnectSolanaAdapter.BInt)
  public static func / (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func /= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func % (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> ConnectSolanaAdapter.BInt
  public static func %= (lhs: inout ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt)
  public static func == (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> Swift.Bool
  public static func < (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> Swift.Bool
  public static func > (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> Swift.Bool
  public static func <= (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> Swift.Bool
  public static func >= (lhs: ConnectSolanaAdapter.BInt, rhs: ConnectSolanaAdapter.BInt) -> Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BIntMath {
  @objc deinit
}
public struct BDouble : Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.CustomStringConvertible, Swift.SignedNumeric, Swift.Comparable, Swift.Hashable {
  public static func -= (lhs: inout ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble)
  public static func += (lhs: inout ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble)
  public init?<T>(exactly _: T) where T : Swift.BinaryInteger
  public var magnitude: Swift.Double
  public typealias Magnitude = Swift.Double
  public static func *= (lhs: inout ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble)
  public init(_ z: Swift.Int)
  public init(_ d: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public var description: Swift.String {
    get
  }
  public func decimalExpansion(precisionAfterComma digits: Swift.Int) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public func rawData() -> (sign: Swift.Bool, numerator: [Swift.UInt64], denominator: [Swift.UInt64])
  public func isPositive() -> Swift.Bool
  public func isNegative() -> Swift.Bool
  public func isZero() -> Swift.Bool
  public mutating func negate()
  public mutating func minimize()
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func != (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func < (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func > (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func <= (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func >= (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> Swift.Bool
public func * (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
public func / (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
public func + (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
prefix public func - (n: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
public func - (lhs: ConnectSolanaAdapter.BDouble, rhs: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
public func abs(_ lhs: ConnectSolanaAdapter.BDouble) -> ConnectSolanaAdapter.BDouble
public enum RIPEMD {
  public static func digest(_ input: Foundation.Data, bitlength: Swift.Int = 160) -> Foundation.Data
  public static func pad(_ data: Foundation.Data) -> Foundation.Data
  public static func getWordsInSection(_ data: Foundation.Data, _ section: Swift.Int) -> [Swift.UInt32]
  public static func encodeWords(_ input: [Swift.UInt32]) -> Foundation.Data
  public static func digest(_ input: Foundation.Data, bitlength: Swift.Int = 160) -> Swift.String
  public static func hexStringDigest(_ input: Swift.String, bitlength: Swift.Int = 160) -> Foundation.Data
  public static func hexStringDigest(_ input: Swift.String, bitlength: Swift.Int = 160) -> Swift.String
  public static func asciiDigest(_ input: Swift.String, bitlength: Swift.Int = 160) -> Foundation.Data
  public static func asciiDigest(_ input: Swift.String, bitlength: Swift.Int = 160) -> Swift.String
}
public enum TokenProgram : ConnectSolanaAdapter.SolanaBasicProgram {
  public enum Index {
  }
  public static var id: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static func initializeMintInstruction(mint: ConnectSolanaAdapter.PublicKey, decimals: Swift.UInt8, authority: ConnectSolanaAdapter.PublicKey, freezeAuthority: ConnectSolanaAdapter.PublicKey?) -> ConnectSolanaAdapter.TransactionInstruction
  public static func initializeAccountInstruction(account: ConnectSolanaAdapter.PublicKey, mint: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey) -> ConnectSolanaAdapter.TransactionInstruction
  public static func transferInstruction(source: ConnectSolanaAdapter.PublicKey, destination: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, amount: Swift.UInt64) -> ConnectSolanaAdapter.TransactionInstruction
  public static func transferCheckedInstruction(source: ConnectSolanaAdapter.PublicKey, mint: ConnectSolanaAdapter.PublicKey, destination: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, multiSigners: [ConnectSolanaAdapter.PublicKey], amount: ConnectSolanaAdapter.Lamports, decimals: ConnectSolanaAdapter.Decimals) -> ConnectSolanaAdapter.TransactionInstruction
  public static func burnCheckedInstruction(mint: ConnectSolanaAdapter.PublicKey, account: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, amount: Swift.UInt64, decimals: Swift.UInt8) -> ConnectSolanaAdapter.TransactionInstruction
  public static func approveInstruction(account: ConnectSolanaAdapter.PublicKey, delegate: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, multiSigners: [ConnectSolanaAdapter.SolanaAccount], amount: Swift.UInt64) -> ConnectSolanaAdapter.TransactionInstruction
  public static func mintToInstruction(mint: ConnectSolanaAdapter.PublicKey, destination: ConnectSolanaAdapter.PublicKey, authority: ConnectSolanaAdapter.PublicKey, amount: Swift.UInt64) -> ConnectSolanaAdapter.TransactionInstruction
  public static func closeAccountInstruction(account: ConnectSolanaAdapter.PublicKey, destination: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey) -> ConnectSolanaAdapter.TransactionInstruction
  public static func closeAccountInstruction(account: ConnectSolanaAdapter.PublicKey, destination: ConnectSolanaAdapter.PublicKey, owner: ConnectSolanaAdapter.PublicKey, signers: [ConnectSolanaAdapter.PublicKey]) -> ConnectSolanaAdapter.TransactionInstruction
}
public typealias Bignum = ConnectSolanaAdapter.BInt
extension ConnectSolanaAdapter.BInt {
  public var data: Foundation.Data {
    get
  }
  public var dec: Swift.String {
    get
  }
  public var hex: Swift.String {
    get
  }
  public init(hex: Swift.String)
  public init(_ n: Swift.UInt64)
  public init(data: Foundation.Data)
}
extension Foundation.Data {
  public var hexString: Swift.String {
    get
  }
}
extension Foundation.Data {
  public var decodedLength: Swift.Int {
    get
  }
  public mutating func decodeLength() -> Swift.Int
  public static func encodeLength(_ len: Swift.Int) -> Foundation.Data
}
extension Swift.Encodable {
  public var jsonString: Swift.String? {
    get
  }
}
public struct PublicKey : Swift.Codable, Swift.Equatable, Swift.CustomStringConvertible, Swift.Hashable {
  public static let NULL_PUBLICKEY_BYTES: [Swift.UInt8]
  public static let numberOfBytes: Swift.Int
  public let bytes: [Swift.UInt8]
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public init(string: Swift.String?) throws
  public init(data: Foundation.Data) throws
  public init(bytes: [Swift.UInt8]?) throws
  public var base58EncodedString: Swift.String {
    get
  }
  public var data: Foundation.Data {
    get
  }
  public var description: Swift.String {
    get
  }
  public func short(numOfSymbolsRevealed: Swift.Int = 4) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ConnectSolanaAdapter.PublicKey, rhs: ConnectSolanaAdapter.PublicKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension ConnectSolanaAdapter.PublicKey : ConnectSolanaAdapter.BytesEncodable {
}
extension ConnectSolanaAdapter.PublicKey {
  public static func associatedTokenAddress(walletAddress: ConnectSolanaAdapter.PublicKey, tokenMintAddress: ConnectSolanaAdapter.PublicKey) throws -> ConnectSolanaAdapter.PublicKey
  public static func findProgramAddress(seeds: [Foundation.Data], programId: ConnectSolanaAdapter.PublicKey) throws -> (ConnectSolanaAdapter.PublicKey, Swift.UInt8)
  public static func createProgramAddress(seeds: [Foundation.Data], programId: ConnectSolanaAdapter.PublicKey) throws -> ConnectSolanaAdapter.PublicKey
  public static func createWithSeed(fromPublicKey: ConnectSolanaAdapter.PublicKey, seed: Swift.String, programId: ConnectSolanaAdapter.PublicKey) throws -> ConnectSolanaAdapter.PublicKey
}
extension ConnectSolanaAdapter.PublicKey {
  @available(*, deprecated, renamed: "TokenProgram.id")
  public static var tokenProgramId: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var sysvarRent: ConnectSolanaAdapter.PublicKey {
    get
  }
  @available(*, deprecated, renamed: "SystemProgram.id")
  public static var programId: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var wrappedSOLMint: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var solMint: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var swapHostFeeAddress: ConnectSolanaAdapter.PublicKey {
    get
  }
  @available(*, deprecated, renamed: "AssociatedTokenProgram.id")
  public static var splAssociatedTokenAccountProgramId: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var renBTCMint: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var renBTCMintDevnet: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var fake: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static func orcaSwapId(version: Swift.Int = 2) -> ConnectSolanaAdapter.PublicKey
  public static var usdcMint: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var usdtMint: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var dexPID: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static var serumSwapPID: ConnectSolanaAdapter.PublicKey {
    get
  }
  public var isUsdx: Swift.Bool {
    get
  }
}
extension ConnectSolanaAdapter.PublicKey : ConnectSolanaAdapter.BorshCodable {
  public func serialize(to writer: inout Foundation.Data) throws
  public init(from reader: inout ConnectSolanaAdapter.BinaryReader) throws
}
public struct TransactionInstruction : Swift.Codable {
  public let keys: [ConnectSolanaAdapter.SolanaAccount.Meta]
  public let programId: ConnectSolanaAdapter.PublicKey
  public let data: [Swift.UInt8]
  public init(keys: [ConnectSolanaAdapter.SolanaAccount.Meta], programId: ConnectSolanaAdapter.PublicKey, data: [ConnectSolanaAdapter.BytesEncodable])
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum SystemProgram : ConnectSolanaAdapter.SolanaBasicProgram {
  public enum Index {
  }
  public static var id: ConnectSolanaAdapter.PublicKey {
    get
  }
  public static func createAccountInstruction(from fromPublicKey: ConnectSolanaAdapter.PublicKey, toNewPubkey newPubkey: ConnectSolanaAdapter.PublicKey, lamports: Swift.UInt64, space: Swift.UInt64, programId: ConnectSolanaAdapter.PublicKey) -> ConnectSolanaAdapter.TransactionInstruction
  public static func transferInstruction(from fromPublicKey: ConnectSolanaAdapter.PublicKey, to toPublicKey: ConnectSolanaAdapter.PublicKey, lamports: Swift.UInt64) -> ConnectSolanaAdapter.TransactionInstruction
}
public struct DerivablePath : Swift.Hashable, Swift.Codable {
  public enum DerivableType : Swift.String, Swift.CaseIterable, Swift.Codable {
    case bip44Change
    case bip44
    case deprecated
    public init?(rawValue: Swift.String)
    public typealias AllCases = [ConnectSolanaAdapter.DerivablePath.DerivableType]
    public typealias RawValue = Swift.String
    public static var allCases: [ConnectSolanaAdapter.DerivablePath.DerivableType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: ConnectSolanaAdapter.DerivablePath.DerivableType
  public let walletIndex: Swift.Int
  public let accountIndex: Swift.Int?
  public init(type: ConnectSolanaAdapter.DerivablePath.DerivableType, walletIndex: Swift.Int, accountIndex: Swift.Int? = nil)
  public static var `default`: ConnectSolanaAdapter.DerivablePath {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ConnectSolanaAdapter.DerivablePath, b: ConnectSolanaAdapter.DerivablePath) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension Swift.String {
  @inlinable public var bytes: [Swift.UInt8] {
    get {
        data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
    }
  }
}
public typealias BorshCodable = ConnectSolanaAdapter.BorshDeserializable & ConnectSolanaAdapter.BorshSerializable
public enum BorshDecodingError : Swift.Error {
  case unknownData
  public static func == (a: ConnectSolanaAdapter.BorshDecodingError, b: ConnectSolanaAdapter.BorshDecodingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 {
  public var bytes: [Swift.UInt8] {
    get
  }
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
}
extension Swift.Double {
  public func toLamport(decimals: Swift.Int) -> Swift.UInt64
  public func toLamport(decimals: Swift.UInt8) -> Swift.UInt64
}
public protocol BorshSerializable {
  func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.UInt8 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.UInt16 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.UInt32 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.UInt64 : ConnectSolanaAdapter.BorshSerializable {
}
extension ConnectSolanaAdapter.UInt2X : ConnectSolanaAdapter.BorshSerializable where Word == Swift.UInt64 {
}
extension Swift.Int8 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.Int16 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.Int32 : ConnectSolanaAdapter.BorshSerializable {
}
extension Swift.Int64 : ConnectSolanaAdapter.BorshSerializable {
}
extension ConnectSolanaAdapter.Int2X : ConnectSolanaAdapter.BorshSerializable where Word == Swift.UInt64 {
}
extension Swift.FixedWidthInteger {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Float : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Double : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Bool : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.String : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Array : ConnectSolanaAdapter.BorshSerializable where Element : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Set : ConnectSolanaAdapter.BorshSerializable where Element : ConnectSolanaAdapter.BorshSerializable, Element : Swift.Comparable {
  public func serialize(to writer: inout Foundation.Data) throws
}
extension Swift.Dictionary : ConnectSolanaAdapter.BorshSerializable where Key : ConnectSolanaAdapter.BorshSerializable, Key : Swift.Comparable, Value : ConnectSolanaAdapter.BorshSerializable {
  public func serialize(to writer: inout Foundation.Data) throws
}
public enum Network : Swift.String, Swift.CaseIterable, Swift.Codable {
  case mainnetBeta
  case devnet
  case testnet
  public var cluster: Swift.String {
    get
  }
  public var isTestnet: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ConnectSolanaAdapter.Network]
  public typealias RawValue = Swift.String
  public static var allCases: [ConnectSolanaAdapter.Network] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum SolanaError : Swift.Error, Swift.Equatable {
  public static func == (lhs: ConnectSolanaAdapter.SolanaError, rhs: ConnectSolanaAdapter.SolanaError) -> Swift.Bool
  case unauthorized
  case notFound
  case assertionFailed
  case invalidRequest(reason: Swift.String? = nil)
  case invalidResponse(ConnectSolanaAdapter.ResponseError)
  case transactionError(ConnectSolanaAdapter.ErrorDetail, logs: [Swift.String])
  case socket(Swift.Error)
  case transactionHasNotBeenConfirmed
  case other(Swift.String)
  case unknown
  public static var couldNotRetrieveAccountInfo: ConnectSolanaAdapter.SolanaError {
    get
  }
  public static var couldNotRetrieveBuffer: ConnectSolanaAdapter.SolanaError {
    get
  }
}
public enum BufferLayoutError : Swift.Error {
  case NotImplemented
  public static func == (a: ConnectSolanaAdapter.BufferLayoutError, b: ConnectSolanaAdapter.BufferLayoutError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BufferLayout : ConnectSolanaAdapter.BorshDeserializable, ConnectSolanaAdapter.BorshSerializable, Swift.Decodable, Swift.Encodable {
}
extension ConnectSolanaAdapter.BufferLayout {
  public init(from decoder: Swift.Decoder) throws
}
extension Foundation.Data {
  public func ask_BTCHash160() -> Foundation.Data
}
extension ConnectSolanaAdapter.Ed25519HDKey {
  public struct Keys {
    public let key: Foundation.Data
    public let chainCode: Foundation.Data
  }
}
public struct SolanaAccount : Swift.Codable, Swift.Hashable {
  public let phrase: [Swift.String]
  public let publicKey: ConnectSolanaAdapter.PublicKey
  public let secretKey: Foundation.Data
  public init(secretKey: Foundation.Data) throws
  #if compiler(>=5.3) && $AsyncAwait
  public init(phrase: [Swift.String] = [], network: ConnectSolanaAdapter.Network, derivablePath: ConnectSolanaAdapter.DerivablePath? = nil) async throws
  #endif
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ConnectSolanaAdapter.SolanaAccount, b: ConnectSolanaAdapter.SolanaAccount) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ConnectSolanaAdapter.SolanaAccount {
  public struct Meta : Swift.Equatable, Swift.Codable, Swift.CustomDebugStringConvertible {
    public let publicKey: ConnectSolanaAdapter.PublicKey
    public var isSigner: Swift.Bool
    public var isWritable: Swift.Bool
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public init(publicKey: ConnectSolanaAdapter.PublicKey, isSigner: Swift.Bool, isWritable: Swift.Bool)
    public static func readonly(publicKey: ConnectSolanaAdapter.PublicKey, isSigner: Swift.Bool) -> ConnectSolanaAdapter.SolanaAccount.Meta
    public static func writable(publicKey: ConnectSolanaAdapter.PublicKey, isSigner: Swift.Bool) -> ConnectSolanaAdapter.SolanaAccount.Meta
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: ConnectSolanaAdapter.SolanaAccount.Meta, b: ConnectSolanaAdapter.SolanaAccount.Meta) -> Swift.Bool
  }
}
public struct ConfirmedTransaction : Swift.Decodable {
  public let message: ConnectSolanaAdapter.ConfirmedTransaction.Message
  public let signatures: [Swift.String]
  public init(from decoder: Swift.Decoder) throws
}
extension ConnectSolanaAdapter.ConfirmedTransaction {
  public struct Message : Swift.Decodable {
    public let accountKeys: [ConnectSolanaAdapter.SolanaAccount.Meta]
    public let instructions: [ConnectSolanaAdapter.ParsedInstruction]
    public let recentBlockhash: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct ParsedInstruction : Swift.Decodable {
  public struct Parsed : Swift.Decodable {
    public struct Info : Swift.Decodable {
      public let owner: Swift.String?
      public let account: Swift.String?
      public let source: Swift.String?
      public let destination: Swift.String?
      public let lamports: Swift.UInt64?
      public let newAccount: Swift.String?
      public let space: Swift.UInt64?
      public let mint: Swift.String?
      public let rentSysvar: Swift.String?
      public let amount: Swift.String?
      public let delegate: Swift.String?
      public let authority: Swift.String?
      public let wallet: Swift.String?
      public let tokenAmount: ConnectSolanaAdapter.TokenAccountBalance?
      public init(from decoder: Swift.Decoder) throws
    }
    public let info: ConnectSolanaAdapter.ParsedInstruction.Parsed.Info
    public let type: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public let program: Swift.String?
  public let programId: Swift.String
  public let parsed: ConnectSolanaAdapter.ParsedInstruction.Parsed?
  public let data: Swift.String?
  public let accounts: [Swift.String]?
  public init(from decoder: Swift.Decoder) throws
}
extension ConnectSolanaAdapter.PublicKey : Swift.ExpressibleByStringLiteral, Swift.ExpressibleByUnicodeScalarLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public init(stringLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct EncodableWrapper : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public struct RequestAPI : Swift.Encodable {
  public init(method: Swift.String, params: [Swift.Encodable])
  public let id: Swift.String
  public let method: Swift.String
  public let jsonrpc: Swift.String
  public let params: [Swift.Encodable]
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Transfer {
  public static func compile() -> Foundation.Data
}
public struct OwnerInfoParams : Swift.Encodable {
  public let mint: Swift.String?
  public let programId: Swift.String?
  public init(mint: Swift.String?, programId: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias Commitment = Swift.String
public struct RequestConfiguration : Swift.Encodable {
  public let commitment: ConnectSolanaAdapter.Commitment?
  public let encoding: Swift.String?
  public let dataSlice: ConnectSolanaAdapter.DataSlice?
  public let filters: [[Swift.String : ConnectSolanaAdapter.EncodableWrapper]]?
  public let limit: Swift.Int?
  public let before: Swift.String?
  public let until: Swift.String?
  public init?(commitment: ConnectSolanaAdapter.Commitment? = nil, encoding: Swift.String? = nil, dataSlice: ConnectSolanaAdapter.DataSlice? = nil, filters: [[Swift.String : ConnectSolanaAdapter.EncodableWrapper]]? = nil, limit: Swift.Int? = nil, before: Swift.String? = nil, until: Swift.String? = nil)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct DataSlice : Swift.Encodable {
  public let offset: Swift.Int
  public let length: Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias UInt1X = Swift.FixedWidthInteger & Swift.BinaryInteger & Swift.UnsignedInteger & Swift.Codable
public struct UInt2X<Word> : Swift.Hashable, Swift.Codable where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger {
  public typealias IntegerLiteralType = Swift.UInt64
  public typealias Magnitude = ConnectSolanaAdapter.UInt2X<Word>
  public typealias Words = [Word.Words.Element]
  public typealias Stride = Swift.Int
  public var lo: Word
  public var hi: Word
  public init(hi: Word, lo: Word)
  public init(_ source: ConnectSolanaAdapter.UInt2X<Word>)
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ConnectSolanaAdapter.UInt2X {
  public static func == (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> Swift.Bool
}
extension ConnectSolanaAdapter.UInt2X : Swift.ExpressibleByIntegerLiteral {
  public static var isSigned: Swift.Bool {
    get
  }
  public static var bitWidth: Swift.Int {
    get
  }
  public static var min: ConnectSolanaAdapter.UInt2X<Word> {
    get
  }
  public static var max: ConnectSolanaAdapter.UInt2X<Word> {
    get
  }
  public init(_ source: Word)
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init(integerLiteral value: ConnectSolanaAdapter.UInt2X<Word>.IntegerLiteralType)
}
extension ConnectSolanaAdapter.UInt2X : Swift.Comparable {
  public static func < (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> Swift.Bool
}
public enum Int2XConfig {
  public static var useAccelerate: Swift.Bool
}
extension ConnectSolanaAdapter.UInt2X : Swift.Numeric {
  public var magnitude: ConnectSolanaAdapter.UInt2X<Word> {
    get
  }
  prefix public static func ~ (value: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  prefix public static func + (value: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  prefix public static func - (value: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public func addingReportingOverflow(_ other: ConnectSolanaAdapter.UInt2X<Word>) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public func addingReportingOverflow(_ other: Word) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public static func &+ (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func + (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func + (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: Word) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func + (lhs: Word, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func += (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func += (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: Word)
  public func subtractingReportingOverflow(_ other: ConnectSolanaAdapter.UInt2X<Word>) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: Word) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public static func &- (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func - (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func - (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: Word) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func - (lhs: Word, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func -= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func -= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: Word)
  public func multipliedHalfWidth(by other: Word) -> (high: ConnectSolanaAdapter.UInt2X<Word>, low: ConnectSolanaAdapter.UInt2X<Word>.Magnitude)
  public func multipliedFullWidth(by other: ConnectSolanaAdapter.UInt2X<Word>) -> (high: ConnectSolanaAdapter.UInt2X<Word>, low: ConnectSolanaAdapter.UInt2X<Word>.Magnitude)
  public func multipliedReportingOverflow(by other: ConnectSolanaAdapter.UInt2X<Word>) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public static func &* (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func &* (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: Word) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func &* (lhs: Word, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func * (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func * (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: Word) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func * (lhs: Word, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func *= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func *= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: Word)
}
extension ConnectSolanaAdapter.UInt2X {
  public func rShifted(_ width: Swift.Int) -> ConnectSolanaAdapter.UInt2X<Word>
  public func lShifted(_ width: Swift.Int) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func &>> (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func &>>= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func &<< (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func &<<= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
}
extension ConnectSolanaAdapter.UInt2X {
  public func quotientAndRemainder(dividingBy other: Word) -> (quotient: ConnectSolanaAdapter.UInt2X<Word>, remainder: ConnectSolanaAdapter.UInt2X<Word>)
  public func quotientAndRemainder(dividingBy other: ConnectSolanaAdapter.UInt2X<Word>) -> (quotient: ConnectSolanaAdapter.UInt2X<Word>, remainder: ConnectSolanaAdapter.UInt2X<Word>)
  public static func / (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func /= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func % (lhs: ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>) -> ConnectSolanaAdapter.UInt2X<Word>
  public static func %= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public func dividedReportingOverflow(by other: ConnectSolanaAdapter.UInt2X<Word>) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public func remainderReportingOverflow(dividingBy other: ConnectSolanaAdapter.UInt2X<Word>) -> (partialValue: ConnectSolanaAdapter.UInt2X<Word>, overflow: Swift.Bool)
  public func dividingFullWidth(_ dividend: (high: ConnectSolanaAdapter.UInt2X<Word>, low: ConnectSolanaAdapter.UInt2X<Word>.Magnitude)) -> (quotient: ConnectSolanaAdapter.UInt2X<Word>, remainder: ConnectSolanaAdapter.UInt2X<Word>)
}
extension ConnectSolanaAdapter.UInt2X : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public func toString(radix: Swift.Int = 10, uppercase: Swift.Bool = false) -> Swift.String
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.StringProtocol {
  public init?<Word>(_ source: ConnectSolanaAdapter.UInt2X<Word>, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension ConnectSolanaAdapter.UInt2X : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension Swift.Int {
  public init<Word>(_ source: ConnectSolanaAdapter.UInt2X<Word>) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension ConnectSolanaAdapter.UInt2X : Swift.Strideable {
  public func distance(to other: ConnectSolanaAdapter.UInt2X<Word>) -> Swift.Int
  public func advanced(by n: Swift.Int) -> ConnectSolanaAdapter.UInt2X<Word>
}
extension ConnectSolanaAdapter.UInt2X : Swift.BinaryInteger {
  public var bitWidth: Swift.Int {
    get
  }
  public var words: ConnectSolanaAdapter.UInt2X<Word>.Words {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public static func &= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func |= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func ^= (lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: ConnectSolanaAdapter.UInt2X<Word>)
  public static func <<= <RHS>(lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
  public static func >>= <RHS>(lhs: inout ConnectSolanaAdapter.UInt2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
}
extension ConnectSolanaAdapter.UInt2X : Swift.FixedWidthInteger {
  public init(_truncatingBits _: Swift.UInt)
  public var nonzeroBitCount: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var byteSwapped: ConnectSolanaAdapter.UInt2X<Word> {
    get
  }
}
extension ConnectSolanaAdapter.UInt2X : Swift.UnsignedInteger {
}
public typealias UInt128 = ConnectSolanaAdapter.UInt2X<Swift.UInt64>
public typealias UInt256 = ConnectSolanaAdapter.UInt2X<ConnectSolanaAdapter.UInt128>
public typealias UInt512 = ConnectSolanaAdapter.UInt2X<ConnectSolanaAdapter.UInt256>
public typealias UInt1024 = ConnectSolanaAdapter.UInt2X<ConnectSolanaAdapter.UInt512>
public typealias Int1X = Swift.FixedWidthInteger & Swift.BinaryInteger & Swift.SignedInteger & Swift.Codable
public struct Int2X<Word> : Swift.Hashable, Swift.Codable where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger {
  public typealias IntegerLiteralType = Swift.UInt64
  public typealias Magnitude = ConnectSolanaAdapter.UInt2X<Word>
  public typealias Words = [Word.Words.Element]
  public typealias Stride = Swift.Int
  public var rawValue: ConnectSolanaAdapter.Int2X<Word>.Magnitude
  public init(rawValue: ConnectSolanaAdapter.Int2X<Word>.Magnitude)
  public init(_ source: ConnectSolanaAdapter.Int2X<Word>)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ConnectSolanaAdapter.Int2X {
  public static func == (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> Swift.Bool
}
extension ConnectSolanaAdapter.Int2X : Swift.ExpressibleByIntegerLiteral {
  public static var isSigned: Swift.Bool {
    get
  }
  public static var bitWidth: Swift.Int {
    get
  }
  public static var max: ConnectSolanaAdapter.Int2X<Word> {
    get
  }
  public static var min: ConnectSolanaAdapter.Int2X<Word> {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init(integerLiteral value: ConnectSolanaAdapter.Int2X<Word>.IntegerLiteralType)
}
extension ConnectSolanaAdapter.Int2X : Swift.Comparable {
  public var magnitude: ConnectSolanaAdapter.Int2X<Word>.Magnitude {
    get
  }
  public static func < (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> Swift.Bool
}
extension ConnectSolanaAdapter.Int2X : Swift.Numeric {
  prefix public static func ~ (value: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  prefix public static func + (value: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  prefix public static func - (value: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public func addingReportingOverflow(_ other: ConnectSolanaAdapter.Int2X<Word>) -> (partialValue: ConnectSolanaAdapter.Int2X<Word>, overflow: Swift.Bool)
  public static func &+ (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func + (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func += (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public func subtractingReportingOverflow(_ other: ConnectSolanaAdapter.Int2X<Word>) -> (partialValue: ConnectSolanaAdapter.Int2X<Word>, overflow: Swift.Bool)
  public static func &- (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func - (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func -= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public func multipliedFullWidth(by other: ConnectSolanaAdapter.Int2X<Word>) -> (high: ConnectSolanaAdapter.Int2X<Word>, low: ConnectSolanaAdapter.Int2X<Word>.Magnitude)
  public func multipliedReportingOverflow(by other: ConnectSolanaAdapter.Int2X<Word>) -> (partialValue: ConnectSolanaAdapter.Int2X<Word>, overflow: Swift.Bool)
  public static func &* (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func * (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func *= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
}
extension ConnectSolanaAdapter.Int2X {
  public static func &>> (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func &<< (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func &>>= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public static func &<<= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
}
extension ConnectSolanaAdapter.Int2X {
  public func quotientAndRemainder(dividingBy other: ConnectSolanaAdapter.Int2X<Word>) -> (quotient: ConnectSolanaAdapter.Int2X<Word>, remainder: ConnectSolanaAdapter.Int2X<Word>)
  public static func / (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func /= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public static func % (lhs: ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>) -> ConnectSolanaAdapter.Int2X<Word>
  public static func %= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public func dividedReportingOverflow(by other: ConnectSolanaAdapter.Int2X<Word>) -> (partialValue: ConnectSolanaAdapter.Int2X<Word>, overflow: Swift.Bool)
  public func remainderReportingOverflow(dividingBy other: ConnectSolanaAdapter.Int2X<Word>) -> (partialValue: ConnectSolanaAdapter.Int2X<Word>, overflow: Swift.Bool)
  public func dividingFullWidth(_ dividend: (high: ConnectSolanaAdapter.Int2X<Word>, low: ConnectSolanaAdapter.Int2X<Word>.Magnitude)) -> (quotient: ConnectSolanaAdapter.Int2X<Word>, remainder: ConnectSolanaAdapter.Int2X<Word>)
}
extension ConnectSolanaAdapter.Int2X : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public func toString(radix: Swift.Int = 10, uppercase: Swift.Bool = false) -> Swift.String
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension Swift.StringProtocol {
  public init?<Word>(_ source: ConnectSolanaAdapter.Int2X<Word>, radix: Swift.Int = 10, uppercase: Swift.Bool = false) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension ConnectSolanaAdapter.Int2X : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension Swift.Int {
  public init<Word>(_ source: ConnectSolanaAdapter.Int2X<Word>) where Word : Swift.Decodable, Word : Swift.Encodable, Word : Swift.FixedWidthInteger, Word : Swift.UnsignedInteger
}
extension ConnectSolanaAdapter.Int2X : Swift.Strideable {
  public func distance(to other: ConnectSolanaAdapter.Int2X<Word>) -> Swift.Int
  public func advanced(by n: Swift.Int) -> ConnectSolanaAdapter.Int2X<Word>
}
extension ConnectSolanaAdapter.Int2X : Swift.BinaryInteger {
  public var bitWidth: Swift.Int {
    get
  }
  public var words: ConnectSolanaAdapter.Int2X<Word>.Words {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public static func &= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public static func |= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public static func ^= (lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: ConnectSolanaAdapter.Int2X<Word>)
  public static func <<= <RHS>(lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
  public static func >>= <RHS>(lhs: inout ConnectSolanaAdapter.Int2X<Word>, rhs: RHS) where RHS : Swift.BinaryInteger
}
extension ConnectSolanaAdapter.Int2X : Swift.FixedWidthInteger {
  public init(_truncatingBits _: Swift.UInt)
  public var nonzeroBitCount: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var byteSwapped: ConnectSolanaAdapter.Int2X<Word> {
    get
  }
}
extension ConnectSolanaAdapter.Int2X : Swift.SignedInteger {
}
public typealias Int128 = ConnectSolanaAdapter.Int2X<Swift.UInt64>
public typealias Int256 = ConnectSolanaAdapter.Int2X<ConnectSolanaAdapter.UInt128>
public typealias Int512 = ConnectSolanaAdapter.Int2X<ConnectSolanaAdapter.UInt256>
public typealias Int1024 = ConnectSolanaAdapter.Int2X<ConnectSolanaAdapter.UInt512>
public struct EmptyInfo : ConnectSolanaAdapter.BufferLayout {
  public static var BUFFER_LENGTH: Swift.UInt64
  public func encode(to encoder: Swift.Encoder) throws
}
extension ConnectSolanaAdapter.EmptyInfo : ConnectSolanaAdapter.BorshCodable {
  public init(from _: inout ConnectSolanaAdapter.BinaryReader) throws
  public func serialize(to _: inout Foundation.Data) throws
}
public protocol SolanaBasicProgram {
  static var id: ConnectSolanaAdapter.PublicKey { get }
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: [Swift.UInt8] {
    get
  }
  public func toHexString() -> Swift.String
  public func sha256() -> Foundation.Data
}
public enum Ed25519HDKey {
  public typealias Hex = Swift.String
  public typealias Path = Swift.String
  public enum Error : Swift.Error {
    case invalidDerivationPath
    case hmacCanNotAuthenticate
    case canNotGetMasterKeyFromSeed
    public static func == (a: ConnectSolanaAdapter.Ed25519HDKey.Error, b: ConnectSolanaAdapter.Ed25519HDKey.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let hardenedOffset: Swift.Int
  public static func getMasterKeyFromSeed(_ seed: ConnectSolanaAdapter.Ed25519HDKey.Hex) -> Swift.Result<ConnectSolanaAdapter.Ed25519HDKey.Keys, ConnectSolanaAdapter.Ed25519HDKey.Error>
  public static func getPublicKey(privateKey: Foundation.Data, withZeroBytes: Swift.Bool = true) throws -> Foundation.Data
  public static func derivePath(_ path: ConnectSolanaAdapter.Ed25519HDKey.Path, seed: ConnectSolanaAdapter.Ed25519HDKey.Hex, offSet: Swift.Int = hardenedOffset) -> Swift.Result<ConnectSolanaAdapter.Ed25519HDKey.Keys, ConnectSolanaAdapter.Ed25519HDKey.Error>
}
public func sha256(data: Foundation.Data) -> Foundation.Data
extension ConnectSolanaAdapter.RIPEMD.Block.K : Swift.Equatable {}
extension ConnectSolanaAdapter.RIPEMD.Block.K : Swift.Hashable {}
extension ConnectSolanaAdapter.RIPEMD.Block.r : Swift.Equatable {}
extension ConnectSolanaAdapter.RIPEMD.Block.r : Swift.Hashable {}
extension ConnectSolanaAdapter.RIPEMD.Block.s : Swift.Equatable {}
extension ConnectSolanaAdapter.RIPEMD.Block.s : Swift.Hashable {}
extension ConnectSolanaAdapter.DerivablePath.DerivableType : Swift.Equatable {}
extension ConnectSolanaAdapter.DerivablePath.DerivableType : Swift.Hashable {}
extension ConnectSolanaAdapter.DerivablePath.DerivableType : Swift.RawRepresentable {}
extension ConnectSolanaAdapter.BorshDecodingError : Swift.Equatable {}
extension ConnectSolanaAdapter.BorshDecodingError : Swift.Hashable {}
extension ConnectSolanaAdapter.Network : Swift.Equatable {}
extension ConnectSolanaAdapter.Network : Swift.Hashable {}
extension ConnectSolanaAdapter.Network : Swift.RawRepresentable {}
extension ConnectSolanaAdapter.BufferLayoutError : Swift.Equatable {}
extension ConnectSolanaAdapter.BufferLayoutError : Swift.Hashable {}
extension ConnectSolanaAdapter.Ed25519HDKey.Error : Swift.Equatable {}
extension ConnectSolanaAdapter.Ed25519HDKey.Error : Swift.Hashable {}
